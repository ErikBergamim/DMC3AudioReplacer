using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Threading;
using System.Windows.Media;

namespace WpfApp1
{
    public partial class MainWindow : Window
    {
        private string _lastJson;

        private string _rootFolder;
        private string _mapJsonPath;
        private List<JsonVagpMap.VagpItem> _items;
        private List<string> _filteredFiles;

        private MediaPlayer _player;
        private DispatcherTimer _playerTimer;
        private bool _sliderDragging;
        private string _tempPlayWav;

        private sealed class VagpRow
        {
            public string File { get; set; }
            public string Name { get; set; }
            public long Offset { get; set; }
            public long Length { get; set; }
            public int? SampleRate { get; set; }
        }

        public MainWindow()
        {
            InitializeComponent();

            string defaultFolder = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "GData.afs");
            if (Directory.Exists(defaultFolder))
                FolderTextBox.Text = defaultFolder;

            _mapJsonPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "gdata_vagp_map.json");
            LoadMapJsonIfPresent();
            UpdateUiForNoFileSelection();

            _player = new MediaPlayer();
            _player.MediaOpened += Player_MediaOpened;
            _player.MediaEnded += Player_MediaEnded;

            _playerTimer = new DispatcherTimer();
            _playerTimer.Interval = TimeSpan.FromMilliseconds(200);
            _playerTimer.Tick += PlayerTimer_Tick;
        }

        protected override void OnClosed(EventArgs e)
        {
            try
            {
                if (_playerTimer != null) _playerTimer.Stop();
                if (_player != null) _player.Close();
            }
            catch { }

            try { if (!string.IsNullOrEmpty(_tempPlayWav) && File.Exists(_tempPlayWav)) File.Delete(_tempPlayWav); } catch { }

            base.OnClosed(e);
        }

        private void Player_MediaOpened(object sender, EventArgs e)
        {
            PlayerPlayButton.IsEnabled = true;
            PlayerStopButton.IsEnabled = true;
            PlayerSlider.IsEnabled = true;

            UpdatePlayerUi();
            _playerTimer.Start();
        }

        private void Player_MediaEnded(object sender, EventArgs e)
        {
            _playerTimer.Stop();
            _player.Stop();
            PlayerSlider.Value = 0;
            UpdatePlayerUi();
        }

        private void PlayerTimer_Tick(object sender, EventArgs e)
        {
            if (_sliderDragging)
                return;
            UpdatePlayerUi();
        }

        private void UpdatePlayerUi()
        {
            TimeSpan pos = _player.Position;
            TimeSpan dur = (_player.NaturalDuration.HasTimeSpan) ? _player.NaturalDuration.TimeSpan : TimeSpan.Zero;

            double max = dur.TotalSeconds;
            if (max <= 0) max = 1;

            PlayerSlider.Maximum = max;
            PlayerSlider.Value = Math.Max(0, Math.Min(max, pos.TotalSeconds));

            PlayerTimeText.Text = FormatTime(pos) + " / " + FormatTime(dur);
        }

        private static string FormatTime(TimeSpan t)
        {
            if (t.TotalHours >= 1)
                return ((int)t.TotalHours).ToString("00") + ":" + t.Minutes.ToString("00") + ":" + t.Seconds.ToString("00");
            return t.Minutes.ToString("00") + ":" + t.Seconds.ToString("00");
        }

        private void PlayerPlayButton_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                _player.Play();
            }
            catch { }
        }

        private void PlayerStopButton_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                _player.Stop();
                PlayerSlider.Value = 0;
                UpdatePlayerUi();
            }
            catch { }
        }

        private void PlayerSlider_ValueChanged(object sender, RoutedPropertyChangedEventArgs<double> e)
        {
            if (!_sliderDragging)
                return;

            try
            {
                _player.Position = TimeSpan.FromSeconds(PlayerSlider.Value);
                UpdatePlayerUi();
            }
            catch { }
        }

        private void ScanButton_Click(object sender, RoutedEventArgs e)
        {
            string folder = (FolderTextBox.Text ?? string.Empty).Trim();
            if (folder.Length == 0)
            {
                MessageBox.Show("Informe o caminho da pasta GData.afs.");
                return;
            }

            if (!Directory.Exists(folder))
            {
                MessageBox.Show("Pasta não encontrada: " + folder);
                return;
            }

            _rootFolder = folder;

            try { ClearReadOnlyRecursively(_rootFolder); } catch { }

            try
            {
                LoadMapJsonIfPresent();
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString());
                StatusText.Text = "Erro ao carregar JSON.";
                return;
            }

            var files = _items.Select(i => i.File)
                .Where(f => !string.IsNullOrEmpty(f))
                .Distinct(StringComparer.OrdinalIgnoreCase)
                .OrderBy(s => s, StringComparer.OrdinalIgnoreCase)
                .ToList();

            _filteredFiles = files;
            FilesListBox.ItemsSource = files;
            VagpListView.ItemsSource = null;
            SelectedFileText.Text = "";

            StatusText.Text = "Mapa carregado.";
            CountsText.Text = "Arquivos: " + files.Count + " | VAGp: " + _items.Count;
            HintText.Text = "Selecione um arquivo à esquerda para ver os VAGp do JSON.";

            SaveButton.IsEnabled = File.Exists(_mapJsonPath);
        }

        private void SaveButton_Click(object sender, RoutedEventArgs e)
        {
            if (_lastJson == null)
                return;

            var dlg = new Microsoft.Win32.SaveFileDialog();
            dlg.Filter = "JSON (*.json)|*.json|All files (*.*)|*.*";
            dlg.FileName = "gdata_vagp_map.json";
            dlg.InitialDirectory = AppDomain.CurrentDomain.BaseDirectory;

            bool? ok = dlg.ShowDialog(this);
            if (ok == true)
            {
                File.WriteAllText(dlg.FileName, _lastJson, Encoding.UTF8);
                StatusText.Text = "JSON salvo em: " + dlg.FileName;
            }
        }

        private void FileFilterTextBox_TextChanged(object sender, TextChangedEventArgs e)
        {
            if (_items == null)
                return;

            string filter = (FileFilterTextBox.Text ?? string.Empty).Trim();
            var all = _items.Select(i => i.File)
                .Where(f => !string.IsNullOrEmpty(f))
                .Distinct(StringComparer.OrdinalIgnoreCase);

            if (filter.Length != 0)
                all = all.Where(f => f.IndexOf(filter, StringComparison.OrdinalIgnoreCase) >= 0);

            _filteredFiles = all.OrderBy(s => s, StringComparer.OrdinalIgnoreCase).ToList();
            FilesListBox.ItemsSource = _filteredFiles;

            CountsText.Text = "Arquivos: " + _filteredFiles.Count + " | VAGp: " + _items.Count;
        }

        private void FilesListBox_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            string file = FilesListBox.SelectedItem as string;
            if (string.IsNullOrEmpty(file) || _items == null)
            {
                VagpListView.ItemsSource = null;
                SelectedFileText.Text = "";
                return;
            }

            SelectedFileText.Text = "(" + file + ")";

            var rows = _items
                .Where(i => string.Equals(i.File, file, StringComparison.OrdinalIgnoreCase))
                .OrderBy(i => i.Offset)
                .Select(i => new VagpRow
                {
                    File = i.File,
                    Name = i.Name,
                    Offset = i.Offset,
                    Length = i.Length,
                    SampleRate = i.SampleRate
                })
                .ToList();

            VagpListView.ItemsSource = rows;
            HintText.Text = rows.Count > 0 ? ("VAGp no arquivo: " + rows.Count) : "Nenhum VAGp para esse arquivo.";
        }

        private void ExportButton_Click(object sender, RoutedEventArgs e)
        {
            var row = (sender as Button)?.Tag as VagpRow;
            if (row == null) return;

            if (string.IsNullOrEmpty(_rootFolder))
            {
                MessageBox.Show("Informe a pasta GData.afs e clique em Carregar.");
                return;
            }

            string fullPath = Path.Combine(_rootFolder, row.File);
            if (!File.Exists(fullPath))
            {
                MessageBox.Show("Arquivo não encontrado: " + fullPath);
                return;
            }

            var dlg = new Microsoft.Win32.SaveFileDialog();
            dlg.Filter = "BIN (*.bin)|*.bin|All files (*.*)|*.*";
            dlg.FileName = row.Name + "_" + (row.SampleRate.HasValue ? row.SampleRate.Value.ToString() : "nosr") + "_offset" + row.Offset + ".bin";
            dlg.InitialDirectory = _rootFolder;

            bool? ok = dlg.ShowDialog(this);
            if (ok != true) return;

            using (var fs = new FileStream(fullPath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
            {
                fs.Position = row.Offset;
                CopyExactly(fs, dlg.FileName, row.Length);
            }

            StatusText.Text = "Exportado: " + row.Name;
        }

        private void BulkExportButton_Click(object sender, RoutedEventArgs e)
        {
            if (string.IsNullOrEmpty(_rootFolder))
            {
                MessageBox.Show("Informe a pasta GData.afs e clique em Carregar.");
                return;
            }

            string file = FilesListBox.SelectedItem as string;
            if (string.IsNullOrEmpty(file))
            {
                MessageBox.Show("Selecione um arquivo na lista à esquerda.");
                return;
            }

            string targetPac = Path.Combine(_rootFolder, file);
            if (!File.Exists(targetPac))
            {
                MessageBox.Show("Arquivo não encontrado: " + targetPac);
                return;
            }

            string exeDir = AppDomain.CurrentDomain.BaseDirectory;
            string mfaudioPath = Path.Combine(exeDir, "mfaudio.exe");
            if (!File.Exists(mfaudioPath))
            {
                MessageBox.Show("mfaudio.exe não encontrado na pasta do programa: " + mfaudioPath);
                return;
            }

            string outDir = PickFolder("Selecione a pasta para exportar os WAVs");
            if (outDir == null)
                return;

            var entries = _items
                .Where(i => string.Equals(i.File, file, StringComparison.OrdinalIgnoreCase))
                .OrderBy(i => i.Offset)
                .ToList();

            int done = 0;
            foreach (var it in entries)
            {
                if (!it.SampleRate.HasValue)
                    continue;

                string tempVag = Path.Combine(Path.GetTempPath(), "vagp_" + Guid.NewGuid().ToString("N") + ".vag");
                string tempWav = Path.Combine(Path.GetTempPath(), "vagp_" + Guid.NewGuid().ToString("N") + ".wav");

                try
                {
                    using (var fs = new FileStream(targetPac, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                    {
                        fs.Position = it.Offset;
                        CopyExactly(fs, tempVag, it.Length);
                    }

                    TryPatchVagSampleRateBigEndian(tempVag, it.SampleRate.Value);
                    RunMfaudioToWav(mfaudioPath, it.SampleRate.Value, tempVag, tempWav);

                    string outPath = Path.Combine(outDir, it.Name + ".wav");
                    File.Copy(tempWav, outPath, true);
                    done++;
                }
                finally
                {
                    try { if (File.Exists(tempVag)) File.Delete(tempVag); } catch { }
                    try { if (File.Exists(tempWav)) File.Delete(tempWav); } catch { }
                }
            }

            StatusText.Text = "Exportados: " + done + " WAV(s)";
        }

        private void BulkReplaceButton_Click(object sender, RoutedEventArgs e)
        {
            if (string.IsNullOrEmpty(_rootFolder))
            {
                MessageBox.Show("Informe a pasta GData.afs e clique em Carregar.");
                return;
            }

            string file = FilesListBox.SelectedItem as string;
            if (string.IsNullOrEmpty(file))
            {
                MessageBox.Show("Selecione um arquivo na lista à esquerda.");
                return;
            }

            string targetPac = Path.Combine(_rootFolder, file);
            if (!File.Exists(targetPac))
            {
                MessageBox.Show("Arquivo não encontrado: " + targetPac);
                return;
            }

            string exeDir = AppDomain.CurrentDomain.BaseDirectory;
            string mfaudioPath = Path.Combine(exeDir, "mfaudio.exe");
            if (!File.Exists(mfaudioPath))
            {
                MessageBox.Show("mfaudio.exe não encontrado na pasta do programa: " + mfaudioPath);
                return;
            }

            string wavDir = PickFolder("Selecione a pasta contendo WAVs (VAGp1.wav, VAGp2.wav, ...) ");
            if (wavDir == null)
                return;

            try { MakeWritable(targetPac); } catch { }

            // Backup once per file
            string backupPath = targetPac + ".bak";
            if (!File.Exists(backupPath))
            {
                File.Copy(targetPac, backupPath, false);
                try { MakeWritable(backupPath); } catch { }
            }

            var entries = _items
                .Where(i => string.Equals(i.File, file, StringComparison.OrdinalIgnoreCase))
                .OrderBy(i => i.Offset)
                .ToList();

            int patched = 0;
            foreach (var it in entries)
            {
                string wavPath = Path.Combine(wavDir, it.Name + ".wav");
                if (!File.Exists(wavPath))
                    continue;
                if (!it.SampleRate.HasValue)
                    continue;

                string tempRaw = Path.Combine(Path.GetTempPath(), "mfaudio_" + Guid.NewGuid().ToString("N") + ".raw");
                try
                {
                    RunMfaudio(mfaudioPath, it.SampleRate.Value, wavPath, tempRaw);
                    byte[] replacement = File.ReadAllBytes(tempRaw);
                    int toWrite = replacement.Length > it.Length ? (int)it.Length : replacement.Length;

                    using (var fs = new FileStream(targetPac, FileMode.Open, FileAccess.ReadWrite, FileShare.ReadWrite))
                    {
                        fs.Position = it.Offset;
                        fs.Write(replacement, 0, toWrite);
                    }

                    patched++;
                }
                finally
                {
                    try { if (File.Exists(tempRaw)) File.Delete(tempRaw); } catch { }
                }
            }

            StatusText.Text = "Substituídos: " + patched + " VAGp";
        }

        private void IncreaseQualityButton_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                if (string.IsNullOrEmpty(_rootFolder))
                {
                    MessageBox.Show("Informe a pasta GData.afs e clique em Carregar.");
                    return;
                }

                string file = FilesListBox.SelectedItem as string;
                if (string.IsNullOrEmpty(file))
                {
                    MessageBox.Show("Selecione um arquivo na lista à esquerda.");
                    return;
                }

                var row = VagpListView.SelectedItem as VagpRow;
                if (row == null)
                {
                    MessageBox.Show("Selecione um VAGp na lista.");
                    return;
                }

                if (!row.SampleRate.HasValue)
                {
                    MessageBox.Show("SampleRate não encontrado no JSON para este VAGp.");
                    return;
                }

                string prompt = "Novo sample rate (ex: 48000):";
                string input = Microsoft.VisualBasic.Interaction.InputBox(prompt, "Aumentar qualidade", row.SampleRate.Value.ToString());
                input = (input ?? string.Empty).Trim();
                int newRate;
                if (!int.TryParse(input, out newRate) || newRate <= 0)
                {
                    MessageBox.Show("SampleRate inválido.");
                    return;
                }

                int oldRate = row.SampleRate.Value;
                if (newRate == oldRate)
                {
                    MessageBox.Show("O sample rate já é esse valor.");
                    return;
                }

                string targetPac = Path.Combine(_rootFolder, file);
                if (!File.Exists(targetPac))
                {
                    MessageBox.Show("Arquivo não encontrado: " + targetPac);
                    return;
                }

                try { MakeWritable(targetPac); } catch { }

                // Backup once per file
                string backupPath = targetPac + ".bak";
                if (!File.Exists(backupPath))
                {
                    File.Copy(targetPac, backupPath, false);
                    try { MakeWritable(backupPath); } catch { }
                }

                long oldLen = row.Length;
                long newLen = ComputeUpscaledLength(oldLen, oldRate, newRate);
                long delta = newLen - oldLen;

                if (delta <= 0)
                {
                    MessageBox.Show("O novo length calculado não é maior que o atual.");
                    return;
                }

                // Rebuild PAC inserting padding right after the current block.
                string tempPac = Path.Combine(Path.GetTempPath(), "pac_" + Guid.NewGuid().ToString("N") + ".tmp");
                try
                {
                    RebuildPacInsertGap(targetPac, tempPac, row.Offset + oldLen, delta);

                    // Patch VAGp header sample rate inside the block (big-endian at 0x12 from block start)
                    PatchVagpSampleRateInPac(tempPac, row.Offset, newRate);

                    // Update Vagi table entry: start/end and sample rate, then shift all subsequent entries by delta.
                    PatchVagiTableForResize(tempPac, row.Offset, oldLen, delta, newRate);

                    File.Copy(tempPac, targetPac, true);
                }
                finally
                {
                    try { if (File.Exists(tempPac)) File.Delete(tempPac); } catch { }
                }

                // Update JSON mapping (in-memory _items), then persist.
                ApplyJsonResizeAndShift(file, row.Name, newLen, newRate, row.Offset, delta);

                _lastJson = JsonVagpMap.SaveToJson(_items);
                try { JsonVagpMap.Save(_mapJsonPath, _items); } catch { }

                // Refresh current view
                LoadMapJsonIfPresent();
                FilesListBox_SelectionChanged(null, null);

                StatusText.Text = "Qualidade aumentada: " + row.Name + " (Δ=" + delta + ")";
                SaveButton.IsEnabled = File.Exists(_mapJsonPath);
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString());
            }
        }

        private static long ComputeUpscaledLength(long oldLength, int oldRate, int newRate)
        {
            if (oldLength <= 0) return oldLength;
            if (oldRate <= 0 || newRate <= 0) return oldLength;

            double ratio = (double)newRate / (double)oldRate;
            double padded = (double)oldLength * ratio * 1.10;
            long len = (long)Math.Ceiling(padded);

            // Keep at least 1
            if (len < 1) len = 1;
            return len;
        }

        private static void RebuildPacInsertGap(string srcPac, string dstPac, long insertAt, long gapBytes)
        {
            const int bufferSize = 64 * 1024;
            byte[] buffer = new byte[bufferSize];

            using (var src = new FileStream(srcPac, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
            using (var dst = new FileStream(dstPac, FileMode.Create, FileAccess.Write, FileShare.None))
            {
                if (insertAt < 0) insertAt = 0;
                if (insertAt > src.Length) insertAt = src.Length;

                // 1) Copy prefix
                long remaining = insertAt;
                while (remaining > 0)
                {
                    int toRead = remaining > buffer.Length ? buffer.Length : (int)remaining;
                    int read = src.Read(buffer, 0, toRead);
                    if (read <= 0) throw new EndOfStreamException();
                    dst.Write(buffer, 0, read);
                    remaining -= read;
                }

                // 2) Insert gap (zeros)
                if (gapBytes > 0)
                {
                    Array.Clear(buffer, 0, buffer.Length);
                    long g = gapBytes;
                    while (g > 0)
                    {
                        int toWrite = g > buffer.Length ? buffer.Length : (int)g;
                        dst.Write(buffer, 0, toWrite);
                        g -= toWrite;
                    }
                }

                // 3) Copy suffix
                while (true)
                {
                    int read = src.Read(buffer, 0, buffer.Length);
                    if (read <= 0) break;
                    dst.Write(buffer, 0, read);
                }
            }
        }

        private static void PatchVagpSampleRateInPac(string pacPath, long vagpOffset, int sampleRate)
        {
            const int sampleRateOffsetFromVagp = 0x12;

            using (var fs = new FileStream(pacPath, FileMode.Open, FileAccess.ReadWrite, FileShare.Read))
            {
                long pos = vagpOffset;
                if (pos < 0 || pos + 4 > fs.Length)
                    return;

                fs.Position = pos;
                int b0 = fs.ReadByte();
                int b1 = fs.ReadByte();
                int b2 = fs.ReadByte();
                int b3 = fs.ReadByte();
                if (b0 != 0x56 || b1 != 0x41 || b2 != 0x47 || b3 != 0x70)
                    return;

                fs.Position = vagpOffset + sampleRateOffsetFromVagp;
                fs.WriteByte((byte)((sampleRate >> 8) & 0xFF));
                fs.WriteByte((byte)(sampleRate & 0xFF));
            }
        }

        private static void PatchVagiTableForResize(string pacPath, long changedVagpOffset, long oldLen, long delta, int newSampleRate)
        {
            // Uses the same assumptions as GDataScanner.TryReadVagiSampleRates:
            // - "Vagi" signature
            // - first record at +0x1C
            // - stride 0x10
            // Within each 16-byte record: start is 10 bytes before rate, end is 6 bytes before rate.
            byte[] vagiSig = new byte[] { 0x56, 0x61, 0x67, 0x69 };
            const int firstRateOffset = 0x1C;
            const int stride = 0x10;
            const int startRelToRate = -10;
            const int endRelToRate = -6;

            using (var fs = new FileStream(pacPath, FileMode.Open, FileAccess.ReadWrite, FileShare.Read))
            {
                long vagiOffset = FindFirstSignature(fs, vagiSig);
                if (vagiOffset < 0)
                    return;

                long ratePos = vagiOffset + firstRateOffset;
                int index = 0;
                while (ratePos + 2 <= fs.Length)
                {
                    long startPos = ratePos + startRelToRate;
                    long endPos = ratePos + endRelToRate;
                    if (startPos < 0 || endPos < 0 || endPos + 2 > fs.Length || startPos + 2 > fs.Length)
                        break;

                    int? start = TryReadU16LittleEndian(fs, startPos);
                    int? end = TryReadU16LittleEndian(fs, endPos);
                    if (!start.HasValue || !end.HasValue)
                        break;

                    // Heuristic stop: empty record
                    if (start.Value == 0 && end.Value == 0)
                        break;

                    long vagpStart = start.Value;
                    long vagpEnd = end.Value;

                    bool isTarget = (vagpStart == changedVagpOffset) && (vagpEnd == changedVagpOffset + oldLen);

                    if (isTarget)
                    {
                        // Update end and sample rate
                        WriteU16LittleEndian(fs, endPos, (int)(vagpEnd + delta));
                        WriteU16LittleEndian(fs, ratePos, newSampleRate);

                        // Shift all subsequent records
                        long next = ratePos + stride;
                        while (next + 2 <= fs.Length)
                        {
                            long sPos = next + startRelToRate;
                            long ePos = next + endRelToRate;
                            if (sPos < 0 || ePos < 0 || ePos + 2 > fs.Length || sPos + 2 > fs.Length)
                                break;

                            int? s = TryReadU16LittleEndian(fs, sPos);
                            int? e = TryReadU16LittleEndian(fs, ePos);
                            if (!s.HasValue || !e.HasValue)
                                break;
                            if (s.Value == 0 && e.Value == 0)
                                break;

                            WriteU16LittleEndian(fs, sPos, (int)(s.Value + delta));
                            WriteU16LittleEndian(fs, ePos, (int)(e.Value + delta));

                            next += stride;
                        }

                        return;
                    }

                    index++;
                    ratePos += stride;
                }
            }
        }

        private void ApplyJsonResizeAndShift(string file, string name, long newLen, int newRate, long changedOffset, long delta)
        {
            if (_items == null) return;

            // Update target
            for (int i = 0; i < _items.Count; i++)
            {
                var it = _items[i];
                if (!string.Equals(it.File, file, StringComparison.OrdinalIgnoreCase))
                    continue;
                if (!string.Equals(it.Name, name, StringComparison.OrdinalIgnoreCase))
                    continue;
                if (it.Offset != changedOffset)
                    continue;

                it.Length = newLen;
                it.SampleRate = newRate;
                break;
            }

            // Shift subsequent items in the same file
            for (int i = 0; i < _items.Count; i++)
            {
                var it = _items[i];
                if (!string.Equals(it.File, file, StringComparison.OrdinalIgnoreCase))
                    continue;
                if (it.Offset > changedOffset)
                    it.Offset += delta;
            }
        }

        private static void WriteU16LittleEndian(FileStream fs, long pos, int value)
        {
            long old = fs.Position;
            try
            {
                fs.Position = pos;
                fs.WriteByte((byte)(value & 0xFF));
                fs.WriteByte((byte)((value >> 8) & 0xFF));
            }
            finally
            {
                fs.Position = old;
            }
        }

        private static long FindFirstSignature(FileStream fs, byte[] signature)
        {
            if (signature == null || signature.Length == 0)
                return -1;

            const int bufferSize = 64 * 1024;
            byte[] buffer = new byte[bufferSize + (signature.Length - 1)];

            long globalOffset = 0;
            int carried = 0;

            long old = fs.Position;
            try
            {
                fs.Position = 0;
                while (true)
                {
                    int read = fs.Read(buffer, carried, bufferSize);
                    if (read <= 0)
                        return -1;

                    int total = carried + read;
                    int limit = total - signature.Length;

                    for (int i = 0; i <= limit; i++)
                    {
                        if (MatchAt(buffer, i, signature))
                            return globalOffset + i;
                    }

                    carried = signature.Length - 1;
                    if (total < carried)
                        carried = total;

                    Buffer.BlockCopy(buffer, total - carried, buffer, 0, carried);
                    globalOffset += (total - carried);
                }
            }
            finally
            {
                fs.Position = old;
            }
        }

        private static int? TryReadU16LittleEndian(FileStream fs, long pos)
        {
            if (pos < 0 || pos + 2 > fs.Length)
                return null;

            long old = fs.Position;
            try
            {
                fs.Position = pos;
                int lo = fs.ReadByte();
                int hi = fs.ReadByte();
                if (lo < 0 || hi < 0)
                    return null;
                return (hi << 8) | lo;
            }
            finally
            {
                fs.Position = old;
            }
        }

        private static bool MatchAt(byte[] buffer, int index, byte[] signature)
        {
            for (int j = 0; j < signature.Length; j++)
            {
                if (buffer[index + j] != signature[j])
                    return false;
            }
            return true;
        }

        private void LoadMapJsonIfPresent()
        {
            if (!File.Exists(_mapJsonPath))
            {
                StatusText.Text = "Mapa JSON não encontrado: " + _mapJsonPath;
                _items = new List<JsonVagpMap.VagpItem>();
                _lastJson = null;
                return;
            }

            _items = JsonVagpMap.Load(_mapJsonPath);
            _lastJson = File.ReadAllText(_mapJsonPath, Encoding.UTF8);
            StatusText.Text = "Mapa carregado: " + Path.GetFileName(_mapJsonPath);
        }

        private void UpdateUiForNoFileSelection()
        {
            FilesListBox.ItemsSource = null;
            VagpListView.ItemsSource = null;
            SelectedFileText.Text = "";
            HintText.Text = "Informe a pasta GData.afs e clique em Carregar.";
            CountsText.Text = "";
            SaveButton.IsEnabled = File.Exists(_mapJsonPath);

            PlayerPlayButton.IsEnabled = false;
            PlayerStopButton.IsEnabled = false;
            PlayerSlider.IsEnabled = false;
            PlayerSlider.Value = 0;
            PlayerTimeText.Text = "00:00 / 00:00";
        }

        private static void ClearReadOnlyRecursively(string rootFolder)
        {
            foreach (string file in Directory.GetFiles(rootFolder, "*", SearchOption.AllDirectories))
            {
                MakeWritable(file);
            }
        }

        private static void MakeWritable(string filePath)
        {
            FileAttributes attrs = File.GetAttributes(filePath);
            if ((attrs & FileAttributes.ReadOnly) != 0)
            {
                attrs = attrs & ~FileAttributes.ReadOnly;
                File.SetAttributes(filePath, attrs);
            }
        }

        private static void CopyExactly(FileStream input, string outputPath, long length)
        {
            const int bufferSize = 64 * 1024;
            byte[] buffer = new byte[bufferSize];

            using (var outFs = new FileStream(outputPath, FileMode.Create, FileAccess.Write, FileShare.None))
            {
                long remaining = length;
                while (remaining > 0)
                {
                    int toRead = remaining > buffer.Length ? buffer.Length : (int)remaining;
                    int read = input.Read(buffer, 0, toRead);
                    if (read <= 0) throw new EndOfStreamException();
                    outFs.Write(buffer, 0, read);
                    remaining -= read;
                }
            }
        }

        private static void RunMfaudio(string mfaudioPath, int sampleRate, string wavPath, string rawOutPath)
        {
            string args = "/OTVAGC /OC1 /OF" + sampleRate + " \"" + wavPath + "\" \"" + rawOutPath + "\"";

            var psi = new ProcessStartInfo();
            psi.FileName = mfaudioPath;
            psi.Arguments = args;
            psi.WorkingDirectory = Path.GetDirectoryName(mfaudioPath);
            psi.CreateNoWindow = true;
            psi.UseShellExecute = false;
            psi.RedirectStandardOutput = true;
            psi.RedirectStandardError = true;

            using (var p = Process.Start(psi))
            {
                string stdout = p.StandardOutput.ReadToEnd();
                string stderr = p.StandardError.ReadToEnd();
                p.WaitForExit();
                if (p.ExitCode != 0)
                    throw new InvalidOperationException("mfaudio.exe falhou (ExitCode=" + p.ExitCode + ").\n\nSTDOUT:\n" + stdout + "\n\nSTDERR:\n" + stderr);
            }
        }

        private static void RunMfaudioToWav(string mfaudioPath, int sampleRate, string vagPath, string wavOutPath)
        {
            // mfaudio.exe /OTWAVU /OF{sampleRate} "in.vag" "out.wav"
            string args = "/OTWAVU /OF" + sampleRate + " \"" + vagPath + "\" \"" + wavOutPath + "\"";

            var psi = new ProcessStartInfo();
            psi.FileName = mfaudioPath;
            psi.Arguments = args;
            psi.WorkingDirectory = Path.GetDirectoryName(mfaudioPath);
            psi.CreateNoWindow = true;
            psi.UseShellExecute = false;
            psi.RedirectStandardOutput = true;
            psi.RedirectStandardError = true;

            using (var p = Process.Start(psi))
            {
                string stdout = p.StandardOutput.ReadToEnd();
                string stderr = p.StandardError.ReadToEnd();
                p.WaitForExit();

                if (p.ExitCode != 0)
                    throw new InvalidOperationException("mfaudio.exe falhou (ExitCode=" + p.ExitCode + ").\n\nSTDOUT:\n" + stdout + "\n\nSTDERR:\n" + stderr);
            }
        }
    }
}
